image:
  repository: docker-ephemeral.artifactory.opengov.zone/kube-janitor
  tag: 19.12.0
  pullPolicy: IfNotPresent

kubejanitor:
  dryRun: false
  debug: false
  once: true
  # example rules configuration to set TTL for arbitrary objects
  # see https://github.com/hjacobs/kube-janitor for details
  rules:
    - id: temporary-namespaces-delete
      resources:
        - namespaces
        #jmespath: "starts_with(metadata.name, 'ephemeral-')"
      jmespath: "metadata.labels.ephemeral"
      ttl: 5m

    # - id: require-application-label
    #   # remove deployments and statefulsets without a label "application"
    #   resources:
    #     # resources are prefixed with "XXX" to make sure they are not active by accident
    #     # modify the rule as needed and remove the "XXX" prefix to activate
    #     - XXXdeployments
    #     - XXXstatefulsets
    #   # see http://jmespath.org/specification.html
    #   jmespath: "!(spec.template.metadata.labels.application)"
    #   ttl: 4d
    # - id: temporary-pr-namespaces
    #   # delete all namespaces with a name starting with "pr-*"
    #   resources:
    #     # resources are prefixed with "XXX" to make sure they are not active by accident
    #     # modify the rule as needed and remove the "XXX" prefix to activate
    #     - XXXnamespaces
    #   # this uses JMESPath's built-in "starts_with" function
    #   # see http://jmespath.org/specification.html#starts-with
    #   jmespath: "starts_with(metadata.name, 'pr-')"
    #   ttl: 4h

cron:
  schedule: "*/5 * * * *"
  failedJobsHistoryLimit: 3

restartPolicy: OnFailure
resources:
  limits:
    memory: 100Mi
  requests:
    cpu: 5m
    memory: 100Mi

useCustomImagePullSecret: []

# Define toleration to make sure kube-janitor deployed on on-demand instance
tolerations:
  - key: "nodeType"
    operator: "Equal"
    value: "ondemand"
    effect: "NoSchedule"
